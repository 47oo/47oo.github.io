[{"title":"Maven配置文件pom文件详解(四)","date":"2017-04-10T03:17:59.000Z","path":"2017/04/10/Maven配置文件pom文件详解-四/","text":"pom.xml是什么是不是还记得,最开始创建Web项目的时候，要将所有的依赖项放到WEB-INF下面的lib目录下面才会加载。用面向对象的思想来看pom.xml,pom.xml帮你解决了依赖项之间的依赖关系,方便依赖项的替换和查找。pom.xml就是你需要放置需要依赖项的地方，并对子项目进行合理的组合 pom.xml二级节点分配123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;!--modelVersion 描述这个POM文件是遵从哪个版本的项目描述符,这里是由maven的版本来确定的--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 基本配置 --&gt; &lt;groupId&gt;...&lt;/groupId&gt; &lt;artifactId&gt;...&lt;/artifactId&gt; &lt;version&gt;...&lt;/version&gt; &lt;packaging&gt;...&lt;/packaging&gt; &lt;!-- 依赖配置 --&gt; &lt;dependencies&gt;...&lt;/dependencies&gt; &lt;parent&gt;...&lt;/parent&gt; &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt; &lt;modules&gt;...&lt;/modules&gt; &lt;properties&gt;...&lt;/properties&gt; &lt;!-- 构建配置 --&gt; &lt;build&gt;...&lt;/build&gt; &lt;reporting&gt;...&lt;/reporting&gt; &lt;!-- 项目信息 --&gt; &lt;name&gt;...&lt;/name&gt; &lt;description&gt;...&lt;/description&gt; &lt;url&gt;...&lt;/url&gt; &lt;inceptionYear&gt;...&lt;/inceptionYear&gt; &lt;licenses&gt;...&lt;/licenses&gt; &lt;organization&gt;...&lt;/organization&gt; &lt;developers&gt;...&lt;/developers&gt; &lt;contributors&gt;...&lt;/contributors&gt; &lt;!-- 环境设置 --&gt; &lt;issueManagement&gt;...&lt;/issueManagement&gt; &lt;ciManagement&gt;...&lt;/ciManagement&gt; &lt;mailingLists&gt;...&lt;/mailingLists&gt; &lt;scm&gt;...&lt;/scm&gt; &lt;prerequisites&gt;...&lt;/prerequisites&gt; &lt;repositories&gt;...&lt;/repositories&gt; &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt; &lt;distributionManagement&gt;...&lt;/distributionManagement&gt; &lt;profiles&gt;...&lt;/profiles&gt;&lt;/project&gt; 基本配置 modelVersion：pom模型版本，maven2和3只能为4.0.0 groupId：组ID，maven用于定位 artifactId：在组中的唯一ID用于定位 version：项目版本 packaging：项目打包方式，有以下值：pom, jar, - maven-plugin, ejb, war, ear, rar, par 依赖配置 parent 用于确定父项目的坐标 1234567&lt;parent&gt; &lt;groupId&gt;com.oo&lt;/groupId&gt; &lt;artifactId&gt;hh-parent&lt;/artifactId&gt; &lt;!--默认是../pom.xml--&gt; &lt;relativePath&gt;../这个项目的pom文件位置&lt;/relativePath&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; groupId：父项目的构件标识符 artifactId：父项目的唯一标识符 relativePath：Maven首先在当前项目的找父项目的pom，然后在文件系统的这个位置（relativePath），然后在本地仓库，再在远程仓库找。 version：父项目的版本 modules 有些maven项目会做成多模块的，这个标签用于指定当前项目所包含的所有模块。之后对这个项目进行的maven操作，会让所有子模块也进行相同操作。 1234567&lt;!--模块（module的复数）；加载模块列表--&gt;&lt;modules&gt; &lt;!--module通常指的是子模块文件名--&gt; &lt;module&gt;com-a&lt;module/&gt; &lt;module&gt;com-b&lt;module/&gt; &lt;module&gt;com-c&lt;module/&gt;&lt;modules/&gt; properties 用于定义pom常量 1234&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;!--这个长岭可以在pom文件的任意地方通过$&#123;java.version&#125;来引用--&gt; dependencies 项目相关依赖配置，如果在父项目写的依赖，用于子项目引用，一般父项目会将子项目公用的依赖引入（将在之后详细讲解） 1234567891011&lt;dependencies&gt; &lt;!--这边依赖和中央仓库中的一致，就可以引入对应的jar--&gt; &lt;dependency&gt; &lt;!--三点确定唯一的文件--&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!--jar包作用范围,具体内容请看前几张介绍--&gt; &lt;scope&gt;compile/runtime/test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; dependencyManagement配置写法同dependencies 1234567&lt;dependencyManagement&gt; &lt;dependencies&gt; ..... &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!--在父模块中定义后，子模块不会直接使用对应依赖，但是在使用相同依赖的时候可以不加版本号--&gt; 123456789101112131415161718 &lt;!--父项目--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;!--子项目--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--这样的好处是，父项目统一了版本， 而且子项目可以在需要的时候才引用对应的依赖--&gt; 构建过程 build用于配置项目构建相关信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;build&gt; &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt; &lt;sourceDirectory/&gt; &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt; &lt;scriptSourceDirectory/&gt; &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt; &lt;testSourceDirectory/&gt; &lt;!--被编译过的应用程序class文件存放的目录。--&gt; &lt;outputDirectory/&gt; &lt;!--被编译过的测试class文件存放的目录。--&gt; &lt;testOutputDirectory/&gt; &lt;!--使用来自该项目的一系列构建扩展--&gt; &lt;extensions&gt; &lt;!--描述使用到的构建扩展。--&gt; &lt;extension&gt; &lt;!--构建扩展的groupId--&gt; &lt;groupId/&gt; &lt;!--构建扩展的artifactId--&gt; &lt;artifactId/&gt; &lt;!--构建扩展的版本--&gt; &lt;version/&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt; &lt;defaultGoal/&gt; &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt; &lt;resources&gt; &lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt; &lt;targetPath/&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt; &lt;filtering/&gt; &lt;!--描述存放资源的目录，该路径相对POM路径--&gt; &lt;directory/&gt; &lt;!--包含的模式列表，例如**/*.xml.--&gt; &lt;includes/&gt; &lt;!--排除的模式列表，例如**/*.xml--&gt; &lt;excludes/&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt; &lt;testResources&gt; &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--&gt; &lt;testResource&gt; &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!--构建产生的所有文件存放的目录--&gt; &lt;directory/&gt; &lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。--&gt; &lt;finalName/&gt; &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt; &lt;filters/&gt; &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt; &lt;pluginManagement&gt; &lt;!--使用的插件列表 。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。--&gt; &lt;plugin&gt; &lt;!--插件在仓库里的group ID--&gt; &lt;groupId/&gt; &lt;!--插件在仓库里的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--被使用的插件的版本（或版本范围）--&gt; &lt;version/&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt; &lt;extensions/&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt; &lt;executions&gt; &lt;!--execution元素包含了插件执行需要的信息--&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt; &lt;id/&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt; &lt;phase/&gt; &lt;!--配置的执行目标--&gt; &lt;goals/&gt; &lt;!--配置是否被传播到子POM--&gt; &lt;inherited/&gt; &lt;!--作为DOM对象的配置--&gt; &lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--项目引入插件所需要的额外依赖--&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目--&gt; &lt;inherited/&gt; &lt;!--作为DOM对象的配置--&gt; &lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!--使用的插件列表--&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt; &lt;plugin&gt; &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt; &lt;executions&gt; &lt;execution&gt; &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素--&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; reporting该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接123456789101112131415161718192021222324252627282930313233343536 &lt;reporting&gt; &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt; &lt;excludeDefaults/&gt; &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。--&gt; &lt;outputDirectory/&gt; &lt;!--使用的报表插件和他们的配置。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述报表插件需要的信息--&gt; &lt;plugin&gt; &lt;!--报表插件在仓库里的group ID--&gt; &lt;groupId/&gt; &lt;!--报表插件在仓库里的artifact ID--&gt; &lt;artifactId/&gt; &lt;!--被使用的报表插件的版本（或版本范围）--&gt; &lt;version/&gt; &lt;!--任何配置是否被传播到子项目--&gt; &lt;inherited/&gt; &lt;!--报表插件的配置--&gt; &lt;configuration/&gt; &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--&gt; &lt;reportSets&gt; &lt;!--表示报表的一个集合，以及产生该集合的配置--&gt; &lt;reportSet&gt; &lt;!--报表集合的唯一标识符，POM继承时用到--&gt; &lt;id/&gt; &lt;!--产生报表集合时，被使用的报表的配置--&gt; &lt;configuration/&gt; &lt;!--配置是否被继承到子POMs--&gt; &lt;inherited/&gt; &lt;!--这个集合里使用到哪些报表--&gt; &lt;reports/&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; 项目信息 name：给用户提供更为友好的项目名 description：项目描述，maven文档中保存 url：主页的URL，maven文档中保存 inceptionYear：项目创建年份，4位数字。当产生版权信息时需要使用这个值 licenses：该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。（如下） 12345678910&lt;license&gt; &lt;!--license用于法律上的名称--&gt; &lt;name&gt;...&lt;/name&gt; &lt;!--官方的license正文页面的URL--&gt; &lt;url&gt;....&lt;/url&gt; &lt;!--项目分发的主要方式：repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖--&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;!--关于license的补充信息--&gt; &lt;comments&gt;....&lt;/comments&gt; &lt;/license&gt; organization： name 组织名 url 组织主页url developers：项目开发人员列表（如下） contributors：项目其他贡献者列表，同developers 12345678910111213141516171819202122232425262728&lt;developers&gt; &lt;!--某个开发者信息--&gt; &lt;developer&gt; &lt;!--开发者的唯一标识符--&gt; &lt;id&gt;....&lt;/id&gt; &lt;!--开发者的全名--&gt; &lt;name&gt;...&lt;/name&gt; &lt;!--开发者的email--&gt; &lt;email&gt;...&lt;/email&gt; &lt;!--开发者的主页--&gt; &lt;url&gt;...&lt;url/&gt; &lt;!--开发者在项目中的角色--&gt; &lt;roles&gt; &lt;role&gt;Java Dev&lt;/role&gt; &lt;role&gt;Web UI&lt;/role&gt; &lt;/roles&gt; &lt;!--开发者所属组织--&gt; &lt;organization&gt;sun&lt;/organization&gt; &lt;!--开发者所属组织的URL--&gt; &lt;organizationUrl&gt;...&lt;/organizationUrl&gt; &lt;!--开发者属性，如即时消息如何处理等--&gt; &lt;properties&gt; &lt;!-- 和主标签中的properties一样，可以随意定义子标签 --&gt; &lt;/properties&gt; &lt;!--开发者所在时区， -11到12范围内的整数。--&gt; &lt;timezone&gt;-5&lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; 环境设置 issueManagement1234567&lt;!--问题追踪系统--&gt;&lt;issueManagement&gt; &lt;!--系统类型--&gt; &lt;system&gt;Bugzilla&lt;/system&gt;&lt;!--路径--&gt; &lt;url&gt;http://127.0.0.1/bugzilla/&lt;/url&gt;&lt;/issueManagement&gt; ciManagement 12345678910111213141516&lt;!--持续集成系统--&gt;&lt;ciManagement&gt; &lt;system&gt;continuum&lt;/system&gt; &lt;url&gt;http://127.0.0.1:8080/continuum&lt;/url&gt; &lt;notifiers&gt; &lt;notifier&gt; &lt;type&gt;mail&lt;/type&gt; &lt;sendOnError&gt;true&lt;/sendOnError&gt; &lt;sendOnFailure&gt;true&lt;/sendOnFailure&gt; &lt;sendOnSuccess&gt;false&lt;/sendOnSuccess&gt; &lt;sendOnWarning&gt;false&lt;/sendOnWarning&gt; &lt;address&gt;continuum@127.0.0.1&lt;/address&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; system：持续集成系统的名字 url：持续集成系统的URL notifiers：构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） type：通知方式 sendOnError：错误时是否通知 sendOnFailure：失败时是否通知 sendOnSuccess：成功时是否通知 sendOnWarning：警告时是否通知 address：通知发送到的地址 configuration：扩展项 mailingLists 1234567891011121314&lt;!--邮件列表--&gt;&lt;mailingLists&gt; &lt;mailingList&gt; &lt;name&gt;User List&lt;/name&gt; &lt;subscribe&gt;user-subscribe@127.0.0.1&lt;/subscribe&gt; &lt;unsubscribe&gt;user-unsubscribe@127.0.0.1&lt;/unsubscribe&gt; &lt;post&gt;user@127.0.0.1&lt;/post&gt; &lt;archive&gt;http://127.0.0.1/user/&lt;/archive&gt; &lt;otherArchives&gt; &lt;otherArchive&gt;http://base.google.com/base/1/127.0.0.1&lt;/otherArchive&gt; &lt;/otherArchives&gt; &lt;/mailingList&gt; ..... &lt;/mailingLists&gt; subscribe, unsubscribe: 订阅邮件（取消订阅）的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 archive：浏览邮件信息的URL post：接收邮件的地址 scm 1234567&lt;!--允许你配置你的代码库，供Maven web站点和其它插件使用--&gt;&lt;scm&gt; &lt;connection&gt;scm:svn:http://127.0.0.1/svn/my-project&lt;/connection&gt; &lt;developerConnection&gt;scm:svn:https://127.0.0.1/svn/my-project&lt;/developerConnection&gt; &lt;tag&gt;HEAD&lt;/tag&gt; &lt;url&gt;http://127.0.0.1/websvn/my-project&lt;/url&gt; &lt;/scm&gt; connection, developerConnection：这两个表示我们如何连接到maven的版本库。connection只提供读，developerConnection将提供写的请求 写法如：scm:[provider]:[provider_specific] 如果连接到CVS仓库，可以配置：scm:cvs:pserver:127.0.0.1:/cvs/root:my-project tag：项目标签，默认HEAD url：共有仓库路径 prerequisites123&lt;prerequisites&gt; &lt;maven&gt;2.0.6&lt;/maven&gt;&lt;/prerequisites&gt; repositories,pluginRepositories 12345678910111213141516171819202122&lt;!--依赖和扩展的远程仓库列表--&gt;&lt;repositories&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;never&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;fail&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;id&gt;codehausSnapshots&lt;/id&gt; &lt;name&gt;Codehaus Snapshots&lt;/name&gt; &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; ... &lt;/pluginRepositories&gt; releases, snapshots:这是各种构件的策略，release或者snapshot。这两个集合，POM就可以根据独立仓库任意类型的依赖改变策略。如：一个人可能只激活下载snapshot用来开发。 enable：true或者false，决定仓库是否对于各自的类型激活(release 或者 snapshot)。 updatePolicy: 这个元素决定更新频率。maven将比较本地pom的时间戳（存储在仓库的maven数据文件中）和远程的. 有以下选择: always, daily (默认), interval:X (x是代表分钟的整型) ， never. checksumPolicy：当Maven向仓库部署文件的时候，它也部署了相应的校验和文件。可选的为：ignore，fail，warn，或者不正确的校验和。 layout：在上面描述仓库的时候，提到他们有统一的布局。Maven 2有它仓库默认布局。然而，Maven 1.x有不同布局。使用这个元素来表明它是default还是legacy。 distributionManagement 123456&lt;!--它管理的分布在整个构建过程生成的工件和支持文件--&gt;&lt;distributionManagement&gt; ... &lt;downloadUrl&gt;http://mojo.codehaus.org/my-project&lt;/downloadUrl&gt; &lt;status&gt;deployed&lt;/status&gt; &lt;/distributionManagement&gt; downloadUrl: 其他pom可以通过此url的仓库抓取组件 status：给出该构件在远程仓库的状态 none: 默认 converted: 将被早期Maven 2 POM转换过来 partner: 这个项目会从合作者仓库同步过来 deployed: 从Maven 2或3实例部署 verified: 被核实时正确的和最终的 repository 12345678910111213141516171819&lt;!--指定Maven pom从远程下载控件到当前项目的位置和方式，如果snapshotRepository没有被定义则使用repository相关的配置--&gt;&lt;distributionManagement&gt; &lt;repository&gt; &lt;uniqueVersion&gt;false&lt;/uniqueVersion&gt; &lt;id&gt;corp1&lt;/id&gt; &lt;name&gt;Corporate Repository&lt;/name&gt; &lt;url&gt;scp://repo/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion&gt;true&lt;/uniqueVersion&gt; &lt;id&gt;propSnap&lt;/id&gt; &lt;name&gt;Propellors Snapshots&lt;/name&gt; &lt;url&gt;sftp://propellers.net/maven&lt;/url&gt; &lt;layout&gt;legacy&lt;/layout&gt; &lt;/snapshotRepository&gt; ... &lt;/distributionManagement&gt; id, name：仓库的唯一标识 uniqueVersion：true或false，指明控件部署的时候是否获取独立的版本号。 url：repository元素的核心。指定位置和部署协议发布控件到仓库。 layout：布局，default或legacy site 1234567891011&lt;!--多分布存储库,distributionManagement负责定义如何部署项目的网站和文档。--&gt;&lt;distributionManagement&gt; ... &lt;site&gt; &lt;id&gt;mojo.website&lt;/id&gt; &lt;name&gt;Mojo Website&lt;/name&gt; &lt;url&gt;scp://beaver.codehaus.org/home/projects/mojo/public_html/&lt;/url&gt; &lt;/site&gt; ... &lt;/distributionManagement&gt; id, name, url: 这些元素与distributionManagement repository中的相同 relocation1234567891011&lt;!--重新部署-项目不是静态的，是活的。他们需要被搬到更合适的地方--&gt;&lt;distributionManagement&gt; ... &lt;relocation&gt; &lt;groupId&gt;org.apache&lt;/groupId&gt; &lt;artifactId&gt;my-project&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;message&gt;We have moved the Project under Apache&lt;/message&gt; &lt;/relocation&gt; ... &lt;/distributionManagement&gt; profiles 1234567891011121314&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;activation&gt;...&lt;/activation&gt; &lt;build&gt;...&lt;/build&gt; &lt;modules&gt;...&lt;/modules&gt; &lt;repositories&gt;...&lt;/repositories&gt; &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt; &lt;dependencies&gt;...&lt;/dependencies&gt; &lt;reporting&gt;...&lt;/reporting&gt; &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt; &lt;distributionManagement&gt;...&lt;/distributionManagement&gt; &lt;/profile&gt; &lt;/profiles&gt; activation 123456789101112131415161718192021222324&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;jdk&gt;1.5&lt;/jdk&gt; &lt;os&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;property&gt; &lt;name&gt;sparrow-type&lt;/name&gt; &lt;value&gt;African&lt;/value&gt; &lt;/property&gt; &lt;file&gt; &lt;exists&gt;$&#123;basedir&#125;/file2.properties&lt;/exists&gt; &lt;missing&gt;$&#123;basedir&#125;/file1.properties&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; ... &lt;/profile&gt; &lt;/profiles&gt; jdk: 选择的jdk版本,在这里会用1.5的版本 os: 选择使用的操作系统 property: 这个概要文件将激活如果Maven检测到一个属性(一个值可以引用在POM $ {名称})相应的名称值对 file: 文件存在或者失踪时的位置 参考官方文档: maven pom.xml官方地址","tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"Maven概念模型(三)","date":"2017-04-09T10:16:32.000Z","path":"2017/04/09/Maven概念模型-三/","text":"概念模型 Maven三大声明周期 Maven有三套相互独立的生命周期. Clean 在进行真正的构建之前进行的一些清理工作. 1mvn clean #对应命令,经常使用 Default 构建的核心部分，编译，测试，打包，部署等等。 1mvn insatll # 对应命令,经常使用 Site 生成项目报告，站点，发布站点。 1mvn site # 很少使用 Maven 仓库布局根据maven坐标定义每个构建在仓库中唯一存储路径 路径为：groupId/ artifactId/version/ artifactId-version.packaging http://search.maven.org 从中央仓库中搜索jar包 仓库分类 本地仓库 默认位置为/.m2/respository/,每个用户只有一个本地仓库 远程仓库 中央仓库 http://repo1.maven.org/maven2 central 私服 是一种特殊的远程仓库，架设在局域网内的仓库 镜像 用来代替中央仓库,速度一般都比中央仓库快。 Mirror，一般都是国内 Maven文件坐标 Maven坐标主要组成 groupId：定义maven的项目，可以用包名 artifactId:定义项目中的一个模块,一般都是工程名 version：版本 packaging：定义打包方式 坐标的作用： 用来唯一标识一个构件，在依赖里面根据坐标来找需要的构件。 Maven依赖 根据maven坐标找依赖的构件 dependency依赖中scope范围 compile： 默认编译依赖范围。对于编译，测试，运行三种classpath都有效。 test：测试依赖范围。只对于测试classpath有效，只对测试代码有效 provided：已提供依赖范围。对于编译，测试的classpath都有效，但对于运行无效。因为由容器已经提供，例如servlet-api，打包的时候这个包不会打进去 runtime:运行时提供。例如:jdbc驱动Compile、runtime打包会打进去，test、provided打包不会打进去传递性依赖原则： 依赖冲突解决： 路径最近者优先 C-&gt;B-&gt;A，C依赖B，B依赖A，会先用B的jar包 路径相同，第一声明者优先：C-&gt;B,C-&gt;A，必须看B，A在C中哪一个先声明 Maven的聚合和继承主要是可以起到公共配置文件的抽取作用,jar包的统一管理 dependencyManagement中定义的依赖子module不会共享 dependencies中定义的依赖子module可以共享 jar包的统一管理，把jar抽取到parent中 继承关系继承关系不可以循环,比如a继承b，b继承c，c继承d，d继承a 这样是错误的12345678910&lt;!--定义父项目--&gt; &lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.codehaus.hanhao&lt;/groupId&gt; &lt;artifactId&gt;my-parent&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;/project&gt; &lt;!--packaging 类型，需要pom用于parent和合成多个项目。我们需要增加相应的值给父pom，用于子项目继承。--&gt; 12345678910111213&lt;!--子项目配置--&gt;&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.codehaus.hanhao&lt;/groupId&gt; &lt;artifactId&gt;my-parent&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;relativePath&gt;../my-parent&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;my-project&lt;/artifactId&gt; &lt;/project&gt;&lt;!--relativePath可以不需要，但是用于指明parent的目录，用于快速查询。 --&gt; 聚合关系123456789101112&lt;!--合成（或者多个模块） 一个项目有多个模块， 也叫做多重模块，或者合成项目。 --&gt;&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;my-parent&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;modules&gt; &lt;module&gt;my-project1&lt;module&gt; &lt;module&gt;my-project2&lt;module&gt; &lt;/modules&gt; &lt;/project&gt;","tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"Maven使用(二)","date":"2017-04-09T09:56:42.000Z","path":"2017/04/09/Maven使用-二/","text":"Maven的简单使用Maven项目的目录约定 所谓的目录约定只不过是一种习惯，一种默认目录配置,可以做出个性化更改。 手动创建Maven项目,使用Mavenpom.xml文件简单配置 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\"?&gt;&lt;!--最外层是project标签,见名知意--&gt;&lt;project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;&lt;!--所有的Maven项目都必须配置这四个配置项--&gt; &lt;!--modelVersion 描述这个POM文件是遵从哪个版本的项目描述符--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--groupId指的是项目名的项目组，默认就是包名--&gt; &lt;groupId&gt;com.group.hanhao&lt;/groupId&gt; &lt;!--artifactId指的是项目中的某一个模块，默认命名方式是\"项目名-模块名\"--&gt; &lt;artifactId&gt;mavenProjeck&lt;/artifactId&gt; &lt;!--version指的是版本，这里使用的是Maven的快照版本--&gt; &lt;version&gt;SNAPSHOT-0.0.1&lt;/version&gt; &lt;!--项目打包的类型，可以使jar、war、rar、ear、pom，默认是jar--&gt; &lt;packaging&gt;jar/war&lt;/packaging&gt;&lt;!--下面这一块是非必需品--&gt;&lt;!--依赖文件配置--&gt; &lt;dependencies&gt; &lt;!--单个依赖项--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!--使用范围--&gt; &lt;scope&gt;compile/test/provided/runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--但是却是最经常使用的东东--&gt;&lt;/project&gt; Maven 常用命令需要在有pom.xml文件的地方使用12345mvn compile #用于对源文件进行编译mvn test #用于执行test(默认文件夹)的文件,测试命令mvn package # 编译、测试、打包。但是并没有把包同步到仓库mvn install # 编译、测试、打包。并且把包同步到仓库mvn clean #清空默认目录target下的所有文件(可配置成自己喜欢的目录)","tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"Maven介绍(一)","date":"2017-04-09T09:13:19.000Z","path":"2017/04/09/Maven介绍-一/","text":"Maven的基本概念 Maven是一个跨平台的项目管理工具。主要服务于基于Java平台的项目的项目构建，依赖管理和项目信息管理。 项目构建项目构建过程包括【清理项目】→【编译项目】→【测试项目】→【生成测试报告】→【打包项目】→【部署项目】这几个步骤，这六个步骤就是一个项目的完整构建过程。 理想的项目构建是高度自动化，跨平台，可重用的组件，标准化的，使用maven就可以帮我们完成上述所说的项目构建过程。 使用Maven的优势Maven中使用约定，约定java源代码代码必须放在哪个目录下，编译好的java代码又必须放到哪个目录下，这些目录都有明确的约定。 Maven的每一个动作都拥有一个生命周期，例如执行 mvn install 就可以自动执行编译，测试，打包等构建过程 只需要定义一个pom.xml,然后把源码放到默认的目录，Maven帮我们处理其他事情 使用Maven可以进行项目高度自动化构建，依赖管理(这是使用Maven最大的好处)，仓库管理。","tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"Hello World","date":"2017-04-02T04:37:37.324Z","path":"2017/04/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]